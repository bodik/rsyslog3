diff --git a/plugins/omgssapi/omgssapi.c b/plugins/omgssapi/omgssapi.c
index 818a7cf..81623e9 100644
--- a/plugins/omgssapi/omgssapi.c
+++ b/plugins/omgssapi/omgssapi.c
@@ -1,4 +1,7 @@
-/* omgssapi.c
+/* omgssapi.c rewrite
+ * based on omfwd.c rsyslog 7.6.3
+ * modified by bodik@cesnet.cz
+ * 
  * This is the implementation of the build-in forwarding output module.
  *
  * NOTE: read comments in module-template.h to understand how this file
@@ -38,53 +41,62 @@
 #include <errno.h>
 #include <ctype.h>
 #include <unistd.h>
+#include <stdint.h>
 #ifdef USE_NETZIP
 #include <zlib.h>
 #endif
 #include <pthread.h>
 #include <gssapi/gssapi.h>
-#include "dirty.h"
 #include "conf.h"
 #include "syslogd-types.h"
 #include "srUtils.h"
 #include "net.h"
+#include "netstrms.h"
+#include "netstrm.h"
 #include "template.h"
 #include "msg.h"
+#include "tcpclt.h"
 #include "cfsysline.h"
 #include "module-template.h"
 #include "gss-misc.h"
-#include "tcpclt.h"
 #include "glbl.h"
 #include "errmsg.h"
+#include "unicode-helper.h"
 
 MODULE_TYPE_OUTPUT
 MODULE_TYPE_NOKEEP
 MODULE_CNFNAME("omgssapi")
 
-
-static rsRetVal resetConfigVariables(uchar __attribute__((unused)) *pp, void __attribute__((unused)) *pVal);
-
 /* internal structures
  */
 DEF_OMOD_STATIC_DATA
 DEFobjCurrIf(errmsg)
 DEFobjCurrIf(glbl)
+DEFobjCurrIf(net)
+DEFobjCurrIf(netstrms)
+DEFobjCurrIf(netstrm)
 DEFobjCurrIf(gssutil)
 DEFobjCurrIf(tcpclt)
 
 typedef struct _instanceData {
-	char	*f_hname;
-	short	sock;			/* file descriptor */
-	enum { /* TODO: we shoud revisit these definitions */
-		eDestFORW,
-		eDestFORW_SUSP,
-		eDestFORW_UNKN
-	} eDestState;
+	uchar 	*tplName;	/* name of assigned template */
+	netstrms_t *pNS; /* netstream subsystem */
+	netstrm_t *pNetstrm; /* our output netstream */
+	uchar *pszStrmDrvr;
+	uchar *pszStrmDrvrAuthMode;
+	permittedPeers_t *pPermPeers;
+	int iStrmDrvrMode;
+	char	*target;
+	int bIsConnected;  /* are we connected to remote host? 0 - no, 1 - yes, UDP means addr resolved */
 	struct addrinfo *f_addr;
-	int compressionLevel; /* 0 - no compression, else level for zlib */
+	int compressionLevel;	/* 0 - no compression, else level for zlib */
 	char *port;
-	tcpclt_t *pTCPClt;		/* our tcpclt object */
-	gss_ctx_id_t gss_context;
+	/* following fields for TCP-based delivery */
+	TCPFRAMINGMODE tcp_framing;
+	int bResendLastOnRecon; /* should the last message be re-sent on a successful reconnect? */
+	tcpclt_t *pTCPClt;	/* our tcpclt object */
+        char *gss_base_service_name;
+        gss_ctx_id_t gss_context;
 	OM_uint32 gss_flags;
 } instanceData;
 
@@ -95,28 +107,206 @@ typedef enum gss_mode_e {
 	GSSMODE_ENC
 } gss_mode_t;
 
-static struct configSettings_s {
-	uchar	*pszTplName; /* name of the default template to use */
-	char *gss_base_service_name;
+typedef struct configSettings_s {
+	uchar *pszTplName; /* name of the default template to use */
+	uchar *pszStrmDrvr; /* name of the stream driver to use */
+	int iStrmDrvrMode; /* mode for stream driver, driver-dependent (0 mostly means plain tcp) */
+	int bResendLastOnRecon; /* should the last message be re-sent on a successful reconnect? */
+	uchar *pszStrmDrvrAuthMode; /* authentication mode to use */
+	permittedPeers_t *pPermPeers;
+        char *gss_base_service_name;
 	gss_mode_t gss_mode;
-} cs;
+} configSettings_t;
+static configSettings_t cs;
+
+/* tables for interfacing with the v6 config system */
+/* module-global parameters */
+static struct cnfparamdescr modpdescr[] = {
+	{ "template", eCmdHdlrGetWord, 0 },
+};
+static struct cnfparamblk modpblk =
+	{ CNFPARAMBLK_VERSION,
+	  sizeof(modpdescr)/sizeof(struct cnfparamdescr),
+	  modpdescr
+	};
+
+/* action (instance) parameters */
+static struct cnfparamdescr actpdescr[] = {
+	{ "target", eCmdHdlrGetWord, 0 },
+	{ "port", eCmdHdlrGetWord, 0 },
+	{ "tcp_framing", eCmdHdlrGetWord, 0 },
+	{ "ziplevel", eCmdHdlrInt, 0 },
+	{ "streamdriver", eCmdHdlrGetWord, 0 },
+	{ "streamdrivermode", eCmdHdlrInt, 0 },
+	{ "streamdriverauthmode", eCmdHdlrGetWord, 0 },
+	{ "streamdriverpermittedpeers", eCmdHdlrGetWord, 0 },
+	{ "resendlastmsgonreconnect", eCmdHdlrBinary, 0 },
+        { "gssforwardservicename", eCmdHdlrGetWord, 0 },
+        { "gssmode", eCmdHdlrGetWord, 0 },
+	{ "template", eCmdHdlrGetWord, 0 },
+};
+static struct cnfparamblk actpblk =
+	{ CNFPARAMBLK_VERSION,
+	  sizeof(actpdescr)/sizeof(struct cnfparamdescr),
+	  actpdescr
+	};
+
+struct modConfData_s {
+	rsconf_t *pConf;	/* our overall config object */
+	uchar 	*tplName;	/* default template */
+};
+
+static modConfData_t *loadModConf = NULL;/* modConf ptr to use for the current load process */
+static modConfData_t *runModConf = NULL;/* modConf ptr to use for the current exec process */
+
+
+BEGINinitConfVars		/* (re)set config variables to default values */
+CODESTARTinitConfVars 
+	cs.pszTplName = NULL; /* name of the default template to use */
+	cs.pszStrmDrvr = NULL; /* name of the stream driver to use */
+	cs.iStrmDrvrMode = 0; /* mode for stream driver, driver-dependent (0 mostly means plain tcp) */
+	cs.bResendLastOnRecon = 0; /* should the last message be re-sent on a successful reconnect? */
+	cs.pszStrmDrvrAuthMode = NULL; /* authentication mode to use */
+	cs.pPermPeers = NULL;
+        cs.gss_base_service_name = NULL;
+	cs.gss_mode = GSSMODE_ENC;
+ENDinitConfVars
 
 
-/* get the syslog forward port from selector_t. The passed in
- * struct must be one that is setup for forwarding.
- * rgerhards, 2007-06-28
- * We may change the implementation to try to lookup the port
- * if it is unspecified. So far, we use the IANA default auf 514.
+static rsRetVal doTryResume(instanceData *pData);
+
+/* this function gets the default template. It coordinates action between
+ * old-style and new-style configuration parts.
  */
-static char *getFwdSyslogPt(instanceData *pData)
+static inline uchar*
+getDfltTpl(void)
 {
-	assert(pData != NULL);
-	if(pData->port == NULL)
-		return("514");
+	if(loadModConf != NULL && loadModConf->tplName != NULL)
+		return loadModConf->tplName;
+	else if(cs.pszTplName == NULL)
+		return (uchar*)"RSYSLOG_TraditionalForwardFormat";
 	else
-		return(pData->port);
+		return cs.pszTplName;
+}
+
+
+/* set the default template to be used
+ * This is a module-global parameter, and as such needs special handling. It needs to
+ * be coordinated with values set via the v2 config system (rsyslog v6+). What we do
+ * is we do not permit this directive after the v2 config system has been used to set
+ * the parameter.
+ */
+static rsRetVal
+setLegacyDfltTpl(void __attribute__((unused)) *pVal, uchar* newVal)
+{
+	DEFiRet;
+
+	if(loadModConf != NULL && loadModConf->tplName != NULL) {
+		free(newVal);
+		errmsg.LogError(0, RS_RET_ERR, "omgssapi default template already set via module "
+			"global parameter - can no longer be changed");
+		ABORT_FINALIZE(RS_RET_ERR);
+	}
+	free(cs.pszTplName);
+	cs.pszTplName = newVal;
+finalize_it:
+	RETiRet;
+}
+
+
+/* destruct the TCP helper objects
+ * This, for example, is needed after something went wrong.
+ * This function is void because it "can not" fail.
+ * rgerhards, 2008-06-04
+ * Note that we DO NOT discard the current buffer contents
+ * (if any). This permits us to save data between sessions. In
+ * the wort case, some duplication occurs, but we do not
+ * loose data.
+ */
+static inline void
+DestructTCPInstanceData(instanceData *pData)
+{
+        OM_uint32 maj_stat, min_stat;
+	assert(pData != NULL);
+        
+        if (pData->gss_context != GSS_C_NO_CONTEXT) {
+		maj_stat = gss_delete_sec_context(&min_stat, &pData->gss_context, GSS_C_NO_BUFFER);
+		if (maj_stat != GSS_S_COMPLETE)
+			gssutil.display_status("deleting context", maj_stat, min_stat);
+	}
+        
+	if(pData->pNetstrm != NULL)
+		netstrm.Destruct(&pData->pNetstrm);
+	if(pData->pNS != NULL)
+		netstrms.Destruct(&pData->pNS);
 }
 
+
+BEGINbeginCnfLoad
+CODESTARTbeginCnfLoad
+	loadModConf = pModConf;
+	pModConf->pConf = pConf;
+	pModConf->tplName = NULL;
+ENDbeginCnfLoad
+
+BEGINsetModCnf
+	struct cnfparamvals *pvals = NULL;
+	int i;
+CODESTARTsetModCnf
+	pvals = nvlstGetParams(lst, &modpblk, NULL);
+	if(pvals == NULL) {
+		errmsg.LogError(0, RS_RET_MISSING_CNFPARAMS, "error processing module "
+				"config parameters [module(...)]");
+		ABORT_FINALIZE(RS_RET_MISSING_CNFPARAMS);
+	}
+
+	if(Debug) {
+		dbgprintf("module (global) param blk for omgssapi:\n");
+		cnfparamsPrint(&modpblk, pvals);
+	}
+
+	for(i = 0 ; i < modpblk.nParams ; ++i) {
+		if(!pvals[i].bUsed)
+			continue;
+		if(!strcmp(modpblk.descr[i].name, "template")) {
+			loadModConf->tplName = (uchar*)es_str2cstr(pvals[i].val.d.estr, NULL);
+			if(cs.pszTplName != NULL) {
+				errmsg.LogError(0, RS_RET_DUP_PARAM, "omgssapi: warning: default template "
+						"was already set via legacy directive - may lead to inconsistent "
+						"results.");
+			}
+		} else {
+			dbgprintf("omgssapi: program error, non-handled "
+			  "param '%s' in beginCnfLoad\n", modpblk.descr[i].name);
+		}
+	}
+finalize_it:
+	if(pvals != NULL)
+		cnfparamvalsDestruct(pvals, &modpblk);
+ENDsetModCnf
+
+BEGINendCnfLoad
+CODESTARTendCnfLoad
+	loadModConf = NULL; /* done loading */
+	/* free legacy config vars */
+	free(cs.pszTplName);
+	cs.pszTplName = NULL;
+ENDendCnfLoad
+
+BEGINcheckCnf
+CODESTARTcheckCnf
+ENDcheckCnf
+
+BEGINactivateCnf
+CODESTARTactivateCnf
+	runModConf = pModConf;
+ENDactivateCnf
+
+BEGINfreeCnf
+CODESTARTfreeCnf
+	free(pModConf->tplName);
+ENDfreeCnf
+
 BEGINcreateInstance
 CODESTARTcreateInstance
 ENDcreateInstance
@@ -130,206 +320,245 @@ ENDisCompatibleWithFeature
 
 
 BEGINfreeInstance
-OM_uint32 maj_stat, min_stat;
 CODESTARTfreeInstance
-	switch (pData->eDestState) {
-		case eDestFORW:
-		case eDestFORW_SUSP:
-			freeaddrinfo(pData->f_addr);
-			/* fall through */
-		case eDestFORW_UNKN:
-			if(pData->port != NULL)
-				free(pData->port);
-			break;
-	}
+	/* final cleanup */
+	DestructTCPInstanceData(pData);
 
-	if (pData->gss_context != GSS_C_NO_CONTEXT) {
-		maj_stat = gss_delete_sec_context(&min_stat, &pData->gss_context, GSS_C_NO_BUFFER);
-		if (maj_stat != GSS_S_COMPLETE)
-			gssutil.display_status("deleting context", maj_stat, min_stat);
-	}
-	/* this is meant to be done when module is unloaded,
+        /* this is meant to be done when module is unloaded,
 	   but since this module is static...
 	*/
-	free(cs.gss_base_service_name);
-	cs.gss_base_service_name = NULL;
+        /* free(cs.gss_base_service_name);
+	cs.gss_base_service_name = NULL; */
 
-	/* final cleanup */
 	tcpclt.Destruct(&pData->pTCPClt);
-	if(pData->sock >= 0)
-		close(pData->sock);
+	free(pData->port);
+	free(pData->target);
+	free(pData->pszStrmDrvr);
+	free(pData->pszStrmDrvrAuthMode);
+        free(pData->gss_base_service_name);
+	net.DestructPermittedPeers(&pData->pPermPeers);
+        
 
-	if(pData->f_hname != NULL)
-		free(pData->f_hname);
 ENDfreeInstance
 
 
 BEGINdbgPrintInstInfo
 CODESTARTdbgPrintInstInfo
-	printf("%s", pData->f_hname);
+	dbgprintf("%s", pData->target);
 ENDdbgPrintInstInfo
 
 
+/* set the permitted peers -- rgerhards, 2008-05-19
+ */
+static rsRetVal
+setPermittedPeer(void __attribute__((unused)) *pVal, uchar *pszID)
+{
+	DEFiRet;
+	CHKiRet(net.AddPermittedPeer(&cs.pPermPeers, pszID));
+	free(pszID); /* no longer needed, but we must free it as of interface def */
+finalize_it:
+	RETiRet;
+}
+
+
+
+/* CODE FOR SENDING TCP MESSAGES */
+
+/* Send a frame via plain TCP protocol
+ * rgerhards, 2007-12-28
+ */
+static rsRetVal TCPSendGSSFrame(void *pvData, char *msg, size_t len)
+{
+	DEFiRet;
+	ssize_t lenSend;
+
+	int s;
+	gss_ctx_id_t *context;
+	OM_uint32 maj_stat, min_stat;
+	gss_buffer_desc in_buf, out_buf;
+
+	instanceData *pData = (instanceData *) pvData;
+
+	lenSend = len;
+
+	netstrm.GetSock(pData->pNetstrm, &s);
+	context = &pData->gss_context;
+	in_buf.value = msg;
+	in_buf.length = len;
+	maj_stat = gss_wrap(&min_stat, *context, (cs.gss_mode == GSSMODE_ENC) ? 1 : 0, GSS_C_QOP_DEFAULT,
+			    &in_buf, NULL, &out_buf);
+	if (maj_stat != GSS_S_COMPLETE) {
+		gssutil.display_status("wrapping message", maj_stat, min_stat);
+		ABORT_FINALIZE(RS_RET_ERR);
+	}
+	
+	if (gssutil.send_token(s, &out_buf) < 0) {
+		ABORT_FINALIZE(RS_RET_ERR);
+	}
+	gss_release_buffer(&min_stat, &out_buf);
+
+	dbgprintf("GSS sent %ld bytes, requested %ld\n", (long) lenSend, (long) len);
+
+finalize_it:
+	if(iRet != RS_RET_OK) {
+
+		errmsg.LogError(0, RS_RET_GSS_SENDINIT_ERROR, "GSS-API Context initialization failed\n");
+		gss_release_buffer(&min_stat, &out_buf);
+		if (*context != GSS_C_NO_CONTEXT) {
+			gss_delete_sec_context(&min_stat, context, GSS_C_NO_BUFFER);
+			*context = GSS_C_NO_CONTEXT;
+		}
+		DestructTCPInstanceData(pData);
+	}
+	RETiRet;
+}
+
 /* This function is called immediately before a send retry is attempted.
  * It shall clean up whatever makes sense.
  * rgerhards, 2007-12-28
  */
-static rsRetVal TCPSendGSSPrepRetry(void __attribute__((unused)) *pData)
+static rsRetVal TCPSendGSSPrepRetry(void *pvData)
 {
-	/* in case of TCP/GSS, there is nothing to do */
-	return RS_RET_OK;
+	DEFiRet;
+	instanceData *pData = (instanceData *) pvData;
+
+	assert(pData != NULL);
+	DestructTCPInstanceData(pData);
+	RETiRet;
 }
 
 
+/* initializes everything so that TCPSend can work.
+ * rgerhards, 2007-12-28
+ */
 static rsRetVal TCPSendGSSInit(void *pvData)
 {
 	DEFiRet;
-	int s = -1;
+
 	char *base;
 	OM_uint32 maj_stat, min_stat, init_sec_min_stat, *sess_flags, ret_flags;
 	gss_buffer_desc out_tok, in_tok;
 	gss_buffer_t tok_ptr;
 	gss_name_t target_name;
-	gss_ctx_id_t *context;
+	gss_ctx_id_t *context = NULL;
+	int s;
+
 	instanceData *pData = (instanceData *) pvData;
 
 	assert(pData != NULL);
+	if(pData->pNetstrm == NULL) {
+		base = (pData->gss_base_service_name == NULL) ? "host" : pData->gss_base_service_name;
+		out_tok.length = strlen(pData->target) + strlen(base) + 2;
+		CHKmalloc(out_tok.value = MALLOC(out_tok.length));
+		strcpy(out_tok.value, base);
+		strcat(out_tok.value, "@");
+		strcat(out_tok.value, pData->target);
+		dbgprintf("GSS-API service name: %s\n", (char*) out_tok.value);
+		tok_ptr = GSS_C_NO_BUFFER;
+		context = &pData->gss_context;
+		*context = GSS_C_NO_CONTEXT;
+		maj_stat = gss_import_name(&min_stat, &out_tok, GSS_C_NT_HOSTBASED_SERVICE, &target_name);
+		free(out_tok.value);
+		out_tok.value = NULL;
+		out_tok.length = 0;
+		if (maj_stat != GSS_S_COMPLETE) {
+			gssutil.display_status("parsing name", maj_stat, min_stat);
+			iRet = RS_RET_ERR;
+			goto finalize_it;
+		}
+		sess_flags = &pData->gss_flags;
+		*sess_flags = GSS_C_MUTUAL_FLAG;
+		if (cs.gss_mode == GSSMODE_MIC) {
+			*sess_flags |= GSS_C_INTEG_FLAG;
+		}
+		if (cs.gss_mode == GSSMODE_ENC) {
+			*sess_flags |= GSS_C_CONF_FLAG;
+		}
+		dbgprintf("GSS-API requested context flags:\n");
+		gssutil.display_ctx_flags(*sess_flags);
 
-	/* if the socket is already initialized, we are done */
-	if(pData->sock > 0)
-		ABORT_FINALIZE(RS_RET_OK);
-
-	base = (cs.gss_base_service_name == NULL) ? "host" : cs.gss_base_service_name;
-	out_tok.length = strlen(pData->f_hname) + strlen(base) + 2;
-	CHKmalloc(out_tok.value = MALLOC(out_tok.length));
-	strcpy(out_tok.value, base);
-	strcat(out_tok.value, "@");
-	strcat(out_tok.value, pData->f_hname);
-	dbgprintf("GSS-API service name: %s\n", (char*) out_tok.value);
-
-	tok_ptr = GSS_C_NO_BUFFER;
-	context = &pData->gss_context;
-	*context = GSS_C_NO_CONTEXT;
-
-	maj_stat = gss_import_name(&min_stat, &out_tok, GSS_C_NT_HOSTBASED_SERVICE, &target_name);
-	free(out_tok.value);
-	out_tok.value = NULL;
-	out_tok.length = 0;
-
-	if (maj_stat != GSS_S_COMPLETE) {
-		gssutil.display_status("parsing name", maj_stat, min_stat);
-		goto fail;
-	}
 
-	sess_flags = &pData->gss_flags;
-	*sess_flags = GSS_C_MUTUAL_FLAG;
-	if (cs.gss_mode == GSSMODE_MIC) {
-		*sess_flags |= GSS_C_INTEG_FLAG;
-	}
-	if (cs.gss_mode == GSSMODE_ENC) {
-		*sess_flags |= GSS_C_CONF_FLAG;
-	}
-	dbgprintf("GSS-API requested context flags:\n");
-	gssutil.display_ctx_flags(*sess_flags);
-
-	do {
-		maj_stat = gss_init_sec_context(&init_sec_min_stat, GSS_C_NO_CREDENTIAL, context,
-						target_name, GSS_C_NO_OID, *sess_flags, 0, NULL,
-						tok_ptr, NULL, &out_tok, &ret_flags, NULL);
-		if (tok_ptr != GSS_C_NO_BUFFER)
-			free(in_tok.value);
-
-		if (maj_stat != GSS_S_COMPLETE
-		    && maj_stat != GSS_S_CONTINUE_NEEDED) {
-			gssutil.display_status("initializing context", maj_stat, init_sec_min_stat);
-			goto fail;
-		}
+		do {
+			maj_stat = gss_init_sec_context(&init_sec_min_stat, GSS_C_NO_CREDENTIAL, context,
+							target_name, GSS_C_NO_OID, *sess_flags, 0, NULL,
+							tok_ptr, NULL, &out_tok, &ret_flags, NULL);
+			if (tok_ptr != GSS_C_NO_BUFFER)
+				free(in_tok.value);
+
+			if (maj_stat != GSS_S_COMPLETE
+			    && maj_stat != GSS_S_CONTINUE_NEEDED) {
+				gssutil.display_status("initializing context", maj_stat, init_sec_min_stat);
+				ABORT_FINALIZE(RS_RET_ERR);
+			}
 
-		if (s == -1)
-			if ((s = pData->sock = tcpclt.CreateSocket(pData->f_addr)) == -1)
-				goto fail;
+			if (pData->pNetstrm == NULL) {
+				CHKiRet(netstrms.Construct(&pData->pNS));
+				/* the stream driver must be set before the object is finalized! */
+				CHKiRet(netstrms.SetDrvrName(pData->pNS, pData->pszStrmDrvr));
+				CHKiRet(netstrms.ConstructFinalize(pData->pNS));
+	
+				/* now create the actual stream and connect to the server */
+				CHKiRet(netstrms.CreateStrm(pData->pNS, &pData->pNetstrm));
+				CHKiRet(netstrm.ConstructFinalize(pData->pNetstrm));
+				CHKiRet(netstrm.SetDrvrMode(pData->pNetstrm, pData->iStrmDrvrMode));
+				/* now set optional params, but only if they were actually configured */
+				if(pData->pszStrmDrvrAuthMode != NULL) {
+					CHKiRet(netstrm.SetDrvrAuthMode(pData->pNetstrm, pData->pszStrmDrvrAuthMode));
+				}
+				if(pData->pPermPeers != NULL) {
+					CHKiRet(netstrm.SetDrvrPermPeers(pData->pNetstrm, pData->pPermPeers));
+				}
+				/* params set, now connect */
+				CHKiRet(netstrm.Connect(pData->pNetstrm, glbl.GetDefPFFamily(),
+					(uchar*)pData->port, (uchar*)pData->target));
+			}
 
-		if (out_tok.length != 0) {
-			dbgprintf("GSS-API Sending init_sec_context token (length: %ld)\n", (long) out_tok.length);
-			if (gssutil.send_token(s, &out_tok) < 0) {
-				goto fail;
+			if (out_tok.length != 0) {
+				dbgprintf("GSS-API Sending init_sec_context token (length: %ld)\n", (long) out_tok.length);
+				netstrm.GetSock(pData->pNetstrm, &s);
+				if (gssutil.send_token(s, &out_tok) < 0) {
+					ABORT_FINALIZE(RS_RET_ERR);
+				}
 			}
-		}
-		gss_release_buffer(&min_stat, &out_tok);
+			gss_release_buffer(&min_stat, &out_tok);
+
+			if (maj_stat == GSS_S_CONTINUE_NEEDED) {
+				dbgprintf("GSS-API Continue needed...\n");
+				if (gssutil.recv_token(s, &in_tok) <= 0) {
+					ABORT_FINALIZE(RS_RET_ERR);
+				}
 
-		if (maj_stat == GSS_S_CONTINUE_NEEDED) {
-			dbgprintf("GSS-API Continue needed...\n");
-			if (gssutil.recv_token(s, &in_tok) <= 0) {
-				goto fail;
+				tok_ptr = &in_tok;
 			}
-			tok_ptr = &in_tok;
-		}
-	} while (maj_stat == GSS_S_CONTINUE_NEEDED);
+		} while (maj_stat == GSS_S_CONTINUE_NEEDED);
 
-	dbgprintf("GSS-API Provided context flags:\n");
-	*sess_flags = ret_flags;
-	gssutil.display_ctx_flags(*sess_flags);
+		dbgprintf("GSS-API Provided context flags:\n");
+		*sess_flags = ret_flags;
+		gssutil.display_ctx_flags(*sess_flags);
+	
+		dbgprintf("GSS-API Context initialized\n");
+		gss_release_name(&min_stat, &target_name);
+	}
 
-	dbgprintf("GSS-API Context initialized\n");
-	gss_release_name(&min_stat, &target_name);
 
 finalize_it:
-	RETiRet;
-
- fail:
-	errmsg.LogError(0, RS_RET_GSS_SENDINIT_ERROR, "GSS-API Context initialization failed\n");
-	gss_release_name(&min_stat, &target_name);
-	gss_release_buffer(&min_stat, &out_tok);
-	if (*context != GSS_C_NO_CONTEXT) {
-		gss_delete_sec_context(&min_stat, context, GSS_C_NO_BUFFER);
-		*context = GSS_C_NO_CONTEXT;
+	if(iRet != RS_RET_OK) {
+		errmsg.LogError(0, RS_RET_GSS_SENDINIT_ERROR, "GSS-API Context initialization failed\n");
+		gss_release_name(&min_stat, &target_name);
+		gss_release_buffer(&min_stat, &out_tok);
+		if (*context != GSS_C_NO_CONTEXT) {
+			gss_delete_sec_context(&min_stat, context, GSS_C_NO_BUFFER);
+			*context = GSS_C_NO_CONTEXT;
+		}
+		DestructTCPInstanceData(pData);
 	}
-	if (s != -1)
-		close(s);
-	pData->sock = -1;
-	ABORT_FINALIZE(RS_RET_GSS_SENDINIT_ERROR);
+	RETiRet;
 }
 
 
-static rsRetVal TCPSendGSSSend(void *pvData, char *msg, size_t len)
-{
-	int s;
-	gss_ctx_id_t *context;
-	OM_uint32 maj_stat, min_stat;
-	gss_buffer_desc in_buf, out_buf;
-	instanceData *pData = (instanceData *) pvData;
 
-	assert(pData != NULL);
-	assert(msg != NULL);
-	assert(len > 0);
 
-	s = pData->sock;
-	context = &pData->gss_context;
-	in_buf.value = msg;
-	in_buf.length = len;
-	maj_stat = gss_wrap(&min_stat, *context, (cs.gss_mode == GSSMODE_ENC) ? 1 : 0, GSS_C_QOP_DEFAULT,
-			    &in_buf, NULL, &out_buf);
-	if (maj_stat != GSS_S_COMPLETE) {
-		gssutil.display_status("wrapping message", maj_stat, min_stat);
-		goto fail;
-	}
-	
-	if (gssutil.send_token(s, &out_buf) < 0) {
-		goto fail;
-	}
-	gss_release_buffer(&min_stat, &out_buf);
 
-	return RS_RET_OK;
-
- fail:
-	close(s);
-	pData->sock = -1;
-	gss_delete_sec_context(&min_stat, context, GSS_C_NO_BUFFER);
-	*context = GSS_C_NO_CONTEXT;
-	gss_release_buffer(&min_stat, &out_buf);
-	dbgprintf("message not (GSS/tcp)send");
-	return RS_RET_GSS_SEND_ERROR;
-}
 
 
 /* try to resume connection if it is not ready
@@ -338,39 +567,21 @@ static rsRetVal TCPSendGSSSend(void *pvData, char *msg, size_t len)
 static rsRetVal doTryResume(instanceData *pData)
 {
 	DEFiRet;
-	struct addrinfo *res;
-	struct addrinfo hints;
-	unsigned e;
-
-	switch (pData->eDestState) {
-	case eDestFORW_SUSP:
-		iRet = RS_RET_OK; /* the actual check happens during doAction() only */
-		pData->eDestState = eDestFORW;
-		break;
-		
-	case eDestFORW_UNKN:
-		/* The remote address is not yet known and needs to be obtained */
-		dbgprintf(" %s\n", pData->f_hname);
-		memset(&hints, 0, sizeof(hints));
-		/* port must be numeric, because config file syntax requests this */
-		/* TODO: this code is a duplicate from cfline() - we should later create
-		 * a common function.
-		 */
-		hints.ai_flags = AI_NUMERICSERV;
-		hints.ai_family = glbl.GetDefPFFamily();
-		hints.ai_socktype = SOCK_STREAM;
-		if((e = getaddrinfo(pData->f_hname,
-				    getFwdSyslogPt(pData), &hints, &res)) == 0) {
-			dbgprintf("%s found, resuming.\n", pData->f_hname);
-			pData->f_addr = res;
-			pData->eDestState = eDestFORW;
-		} else {
-			iRet = RS_RET_SUSPENDED;
+
+	if(pData->bIsConnected)
+		FINALIZE;
+
+	/* The remote address is not yet known and needs to be obtained */
+	dbgprintf(" %s\n", pData->target);
+	CHKiRet(TCPSendGSSInit((void*)pData));
+
+finalize_it:
+	if(iRet != RS_RET_OK) {
+		if(pData->f_addr != NULL) {
+			freeaddrinfo(pData->f_addr);
+			pData->f_addr = NULL;
 		}
-		break;
-	case eDestFORW:
-		/* NOOP */
-		break;
+		iRet = RS_RET_SUSPENDED;
 	}
 
 	RETiRet;
@@ -382,120 +593,311 @@ CODESTARTtryResume
 	iRet = doTryResume(pData);
 ENDtryResume
 
+
+BEGINbeginTransaction
+CODESTARTbeginTransaction
+dbgprintf("omgssapi: beginTransaction\n");
+ENDbeginTransaction
+
+
 BEGINdoAction
-	char *psz = NULL; /* temporary buffering */
+	char *psz; /* temporary buffering */
 	register unsigned l;
 	int iMaxLine;
+#	ifdef	USE_NETZIP
+	Bytef *out = NULL; /* for compression */
+#	endif
 CODESTARTdoAction
-	switch (pData->eDestState) {
-	case eDestFORW_SUSP:
-		dbgprintf("internal error in omgssapi.c, eDestFORW_SUSP in doAction()!\n");
-		iRet = RS_RET_SUSPENDED;
-		break;
-		
-	case eDestFORW_UNKN:
-		dbgprintf("doAction eDestFORW_UNKN\n");
-		iRet = doTryResume(pData);
-		break;
-
-	case eDestFORW:
-		dbgprintf(" %s:%s/%s\n", pData->f_hname, getFwdSyslogPt(pData), "tcp-gssapi");
-		iMaxLine = glbl.GetMaxLine();
-		psz = (char*) ppString[0];
-		l = strlen((char*) psz);
-		if((int) l > iMaxLine)
-			l = iMaxLine;
-
-#		ifdef	USE_NETZIP
-		/* Check if we should compress and, if so, do it. We also
-		 * check if the message is large enough to justify compression.
-		 * The smaller the message, the less likely is a gain in compression.
-		 * To save CPU cycles, we do not try to compress very small messages.
-		 * What "very small" means needs to be configured. Currently, it is
-		 * hard-coded but this may be changed to a config parameter.
-		 * rgerhards, 2006-11-30
-		 */
-		if(pData->compressionLevel && (l > CONF_MIN_SIZE_FOR_COMPRESS)) {
-			Bytef *out;
-			uLongf destLen = sizeof(out) / sizeof(Bytef);
-			uLong srcLen = l;
-			int ret;
-			/* TODO: optimize malloc sequence? -- rgerhards, 2008-09-02 */
-			CHKmalloc(out = (Bytef*) MALLOC(iMaxLine + iMaxLine/100 + 12));
-			out[0] = 'z';
-			out[1] = '\0';
-			ret = compress2((Bytef*) out+1, &destLen, (Bytef*) psz,
-					srcLen, pData->compressionLevel);
-			dbgprintf("Compressing message, length was %d now %d, return state  %d.\n",
-				l, (int) destLen, ret);
-			if(ret != Z_OK) {
-				/* if we fail, we complain, but only in debug mode
-				 * Otherwise, we are silent. In any case, we ignore the
-				 * failed compression and just sent the uncompressed
-				 * data, which is still valid. So this is probably the
-				 * best course of action.
-				 * rgerhards, 2006-11-30
-				 */
-				dbgprintf("Compression failed, sending uncompressed message\n");
-				free(out);
-			} else if(destLen+1 < l) {
-				/* only use compression if there is a gain in using it! */
-				dbgprintf("there is gain in compression, so we do it\n");
-				psz = (char*) out;
-				l = destLen + 1; /* take care for the "z" at message start! */
-			} else {
-				free(out);
-			}
-			++destLen;
-		}
-#		endif
+	CHKiRet(doTryResume(pData));
+
+	iMaxLine = glbl.GetMaxLine();
+
+	dbgprintf(" gssapi %s:%s\n", pData->target, pData->port);
 
-		CHKiRet_Hdlr(tcpclt.Send(pData->pTCPClt, pData, psz, l)) {
-			/* error! */
-			dbgprintf("error forwarding via tcp, suspending\n");
-			pData->eDestState = eDestFORW_SUSP;
-			ABORT_FINALIZE(RS_RET_SUSPENDED);
+	psz = (char*) ppString[0];
+	l = strlen((char*) psz);
+	if((int) l > iMaxLine)
+		l = iMaxLine;
+
+#	ifdef	USE_NETZIP
+	/* Check if we should compress and, if so, do it. We also
+	 * check if the message is large enough to justify compression.
+	 * The smaller the message, the less likely is a gain in compression.
+	 * To save CPU cycles, we do not try to compress very small messages.
+	 * What "very small" means needs to be configured. Currently, it is
+	 * hard-coded but this may be changed to a config parameter.
+	 * rgerhards, 2006-11-30
+	 */
+	if(pData->compressionLevel && (l > CONF_MIN_SIZE_FOR_COMPRESS)) {
+		uLongf destLen = iMaxLine + iMaxLine/100 +12; /* recommended value from zlib doc */
+		uLong srcLen = l;
+		int ret;
+		CHKmalloc(out = (Bytef*) MALLOC(destLen));
+		out[0] = 'z';
+		out[1] = '\0';
+		ret = compress2((Bytef*) out+1, &destLen, (Bytef*) psz,
+				srcLen, pData->compressionLevel);
+		dbgprintf("Compressing message, length was %d now %d, return state  %d.\n",
+			l, (int) destLen, ret);
+		if(ret != Z_OK) {
+			/* if we fail, we complain, but only in debug mode
+			 * Otherwise, we are silent. In any case, we ignore the
+			 * failed compression and just sent the uncompressed
+			 * data, which is still valid. So this is probably the
+			 * best course of action.
+			 * rgerhards, 2006-11-30
+			 */
+			dbgprintf("Compression failed, sending uncompressed message\n");
+		} else if(destLen+1 < l) {
+			/* only use compression if there is a gain in using it! */
+			dbgprintf("there is gain in compression, so we do it\n");
+			psz = (char*) out;
+			l = destLen + 1; /* take care for the "z" at message start! */
 		}
-		break;
+		++destLen;
 	}
+#	endif
+
+	/* forward via TCP */
+	iRet = tcpclt.Send(pData->pTCPClt, pData, psz, l);
+	if(iRet != RS_RET_OK && iRet != RS_RET_DEFER_COMMIT && iRet != RS_RET_PREVIOUS_COMMITTED) {
+		/* error! */
+		dbgprintf("error forwarding via tcp, suspending\n");
+		DestructTCPInstanceData(pData);
+		iRet = RS_RET_SUSPENDED;
+	}
+
 finalize_it:
 #	ifdef USE_NETZIP
-	if((psz != NULL) && (psz != (char*) ppString[0]))  {
-		/* we need to free temporary buffer, alloced above - Naoya Nakazawa, 2010-01-11 */
-		free(psz);
-	}
+	free(out); /* is NULL if it was never used... */
 #	endif
 ENDdoAction
 
 
+BEGINendTransaction
+CODESTARTendTransaction
+dbgprintf("omgssapi: endTransaction\n");
+ENDendTransaction
+
+
+
+/* This function loads TCP support, if not already loaded. It will be called
+ * during config processing. To server ressources, TCP support will only
+ * be loaded if it actually is used. -- rgerhard, 2008-04-17
+ */
+static rsRetVal
+loadTCPSupport(void)
+{
+	DEFiRet;
+	CHKiRet(objUse(netstrms, LM_NETSTRMS_FILENAME));
+	CHKiRet(objUse(netstrm, LM_NETSTRMS_FILENAME));
+        CHKiRet(objUse(gssutil, LM_GSSUTIL_FILENAME));
+	CHKiRet(objUse(tcpclt, LM_TCPCLT_FILENAME));
+
+finalize_it:
+	RETiRet;
+}
+
+
+/* initialize TCP structures (if necessary) after the instance has been
+ * created.
+ */
+static rsRetVal
+initTCP(instanceData *pData)
+{
+	DEFiRet;
+
+        /* create our tcpclt */
+	CHKiRet(tcpclt.Construct(&pData->pTCPClt));
+	CHKiRet(tcpclt.SetResendLastOnRecon(pData->pTCPClt, pData->bResendLastOnRecon));
+	/* and set callbacks */
+	CHKiRet(tcpclt.SetSendInit(pData->pTCPClt, TCPSendGSSInit));
+	CHKiRet(tcpclt.SetSendFrame(pData->pTCPClt, TCPSendGSSFrame));
+	CHKiRet(tcpclt.SetSendPrepRetry(pData->pTCPClt, TCPSendGSSPrepRetry));
+	CHKiRet(tcpclt.SetFraming(pData->pTCPClt, pData->tcp_framing));
+	if(cs.pszStrmDrvr != NULL)
+		CHKmalloc(pData->pszStrmDrvr = (uchar*)strdup((char*)cs.pszStrmDrvr));
+	if(cs.pszStrmDrvrAuthMode != NULL)
+		CHKmalloc(pData->pszStrmDrvrAuthMode =
+			     (uchar*)strdup((char*)cs.pszStrmDrvrAuthMode));
+        if(cs.gss_base_service_name != NULL)
+		CHKmalloc(pData->gss_base_service_name =
+			     (char*)strdup((char*)cs.gss_base_service_name));
+finalize_it:
+	RETiRet;
+}
+
+
+static inline void
+setInstParamDefaults(instanceData *pData)
+{
+	pData->tplName = NULL;
+	pData->tcp_framing = TCP_FRAMING_OCTET_STUFFING;
+	pData->pszStrmDrvr = NULL;
+	pData->pszStrmDrvrAuthMode = NULL;
+	pData->iStrmDrvrMode = 0;
+	pData->bResendLastOnRecon = 0; 
+	pData->pPermPeers = NULL;
+	pData->compressionLevel = 9;
+        pData->gss_base_service_name = NULL;
+        /* pData->gss_mode = GSSMODE_ENC; */
+        pData->gss_flags = 0;
+        /* TODO b: ma to tu vubec byt ? */
+        bzero(pData->gss_context, sizeof(gss_ctx_id_t));
+}
+
+BEGINnewActInst
+	struct cnfparamvals *pvals;
+	uchar *tplToUse;
+	int i;
+	rsRetVal localRet;
+	int complevel = -1;
+CODESTARTnewActInst
+	DBGPRINTF("newActInst (omgssapi)\n");
+
+	pvals = nvlstGetParams(lst, &actpblk, NULL);
+	if(pvals == NULL) {
+		errmsg.LogError(0, RS_RET_MISSING_CNFPARAMS, "omgssapi: either the \"file\" or "
+				"\"dynfile\" parameter must be given");
+		ABORT_FINALIZE(RS_RET_MISSING_CNFPARAMS);
+	}
+
+	if(Debug) {
+		dbgprintf("action param blk in omgssapi:\n");
+		cnfparamsPrint(&actpblk, pvals);
+	}
+
+	CHKiRet(createInstance(&pData));
+	setInstParamDefaults(pData);
+        
+        localRet = loadTCPSupport();
+	if(localRet != RS_RET_OK) {
+		errmsg.LogError(0, localRet, "could not activate network stream modules for GSS-API "
+				"(internal error %d) - are modules missing?", localRet);
+		ABORT_FINALIZE(localRet);
+	}
+
+	for(i = 0 ; i < actpblk.nParams ; ++i) {
+		if(!pvals[i].bUsed)
+			continue;
+		if(!strcmp(actpblk.descr[i].name, "target")) {
+			pData->target = es_str2cstr(pvals[i].val.d.estr, NULL);
+		} else if(!strcmp(actpblk.descr[i].name, "port")) {
+			pData->port = es_str2cstr(pvals[i].val.d.estr, NULL);
+		} else if(!strcmp(actpblk.descr[i].name, "tcp_framing")) {
+			if(!es_strcasebufcmp(pvals[i].val.d.estr, (uchar*)"traditional", 11)) {
+				pData->tcp_framing = TCP_FRAMING_OCTET_STUFFING;
+			} else if(!es_strcasebufcmp(pvals[i].val.d.estr, (uchar*)"octet-counted", 13)) {
+				pData->tcp_framing = TCP_FRAMING_OCTET_COUNTING;
+			} else {
+				uchar *str;
+				str = (uchar*)es_str2cstr(pvals[i].val.d.estr, NULL);
+				errmsg.LogError(0, RS_RET_CNF_INVLD_FRAMING,
+						"omfwd: invalid framing \"%s\"", str);
+				free(str);
+				ABORT_FINALIZE(RS_RET_CNF_INVLD_FRAMING );
+			}
+		} else if(!strcmp(actpblk.descr[i].name, "streamdriver")) {
+			pData->pszStrmDrvr = (uchar*)es_str2cstr(pvals[i].val.d.estr, NULL);
+		} else if(!strcmp(actpblk.descr[i].name, "streamdrivermode")) {
+			pData->iStrmDrvrMode = pvals[i].val.d.n;
+		} else if(!strcmp(actpblk.descr[i].name, "streamdriverauthmode")) {
+			pData->pszStrmDrvrAuthMode = (uchar*)es_str2cstr(pvals[i].val.d.estr, NULL);
+		} else if(!strcmp(actpblk.descr[i].name, "streamdriverpermittedpeers")) {
+			uchar *start, *str;
+			uchar save;
+			uchar *p;
+			int lenStr;
+			str = (uchar*)es_str2cstr(pvals[i].val.d.estr, NULL);
+			start = str;
+			lenStr = ustrlen(start); /* we need length after '\0' has been dropped... */
+			while(lenStr > 0) {
+				p = start;
+				while(*p && *p != ',' && lenStr--)
+					p++;
+				if(*p == ',') {
+					*p = '\0';
+				}
+				save = *(p+1); /* we always have this, at least the \0 byte at EOS */
+				*(p+1) = '\0';
+				if(*start == '\0') {
+					DBGPRINTF("omfwd: ignoring empty permitted peer\n");
+				} else {
+					dbgprintf("omfwd: adding permitted peer: '%s'\n", start);
+					CHKiRet(net.AddPermittedPeer(&(pData->pPermPeers), start));
+				}
+				start = p+1;
+				if(lenStr)
+					--lenStr;
+				*(p+1) = save;
+			}
+			free(str);
+		} else if(!strcmp(actpblk.descr[i].name, "ziplevel")) {
+#			ifdef USE_NETZIP
+			complevel = pvals[i].val.d.n;
+			if(complevel >= 0 && complevel <= 10) {
+				pData->compressionLevel = complevel;
+			} else {
+				errmsg.LogError(0, NO_ERRCODE, "Invalid ziplevel %d specified in "
+					 "forwardig action - NOT turning on compression.",
+					 complevel);
+			}
+#			else
+			errmsg.LogError(0, NO_ERRCODE, "Compression requested, but rsyslogd is not compiled "
+				 "with compression support - request ignored.");
+#			endif /* #ifdef USE_NETZIP */
+		} else if(!strcmp(actpblk.descr[i].name, "resendlastmsgonreconnect")) {
+			pData->bResendLastOnRecon = (int) pvals[i].val.d.n;
+		} else if(!strcmp(actpblk.descr[i].name, "gssforwardservicename")) {
+			pData->gss_base_service_name = (char*)es_str2cstr(pvals[i].val.d.estr, NULL);
+		} /* else if(!strcmp(actpblk.descr[i].name, "gssmode")) {
+			pData->gss_mode = (uchar*)es_str2cstr(pvals[i].val.d.estr, NULL);
+		} */ else if(!strcmp(actpblk.descr[i].name, "template")) {
+			pData->tplName = (uchar*)es_str2cstr(pvals[i].val.d.estr, NULL);
+		} else {
+			DBGPRINTF("omgssapi: program error, non-handled "
+			  "param '%s'\n", actpblk.descr[i].name);
+		}
+	}
+
+	if(complevel != -1) {
+		pData->compressionLevel = complevel;
+	}
+
+	CODE_STD_STRING_REQUESTnewActInst(1)
+
+	tplToUse = ustrdup((pData->tplName == NULL) ? getDfltTpl() : pData->tplName);
+	CHKiRet(OMSRsetEntry(*ppOMSR, 0, tplToUse, OMSR_NO_RQD_TPL_OPTS));
+
+	CHKiRet(initTCP(pData));
+CODE_STD_FINALIZERnewActInst
+	cnfparamvalsDestruct(pvals, &actpblk);
+ENDnewActInst
+
+
 BEGINparseSelectorAct
 	uchar *q;
 	int i;
-        int error;
-	int bErr;
-        struct addrinfo hints, *res;
+	rsRetVal localRet;
+        struct addrinfo;
 	TCPFRAMINGMODE tcp_framing = TCP_FRAMING_OCTET_STUFFING;
 CODESTARTparseSelectorAct
 CODE_STD_STRING_REQUESTparseSelectorAct(1)
-	/* first check if this config line is actually for us
-	 * The first test [*p == '>'] can be skipped if a module shall only
-	 * support the newer slection syntax [:modname:]. This is in fact
-	 * recommended for new modules. Please note that over time this part
-	 * will be handled by rsyslogd itself, but for the time being it is
-	 * a good compromise to do it at the module level.
-	 * rgerhards, 2007-10-15
-	 */
-
 	if(!strncmp((char*) p, ":omgssapi:", sizeof(":omgssapi:") - 1)) {
 		p += sizeof(":omgssapi:") - 1; /* eat indicator sequence (-1 because of '\0'!) */
+
+		CHKiRet(createInstance(&pData));
+	
+		localRet = loadTCPSupport();
+		if(localRet != RS_RET_OK) {
+			errmsg.LogError(0, localRet, "could not activate network stream modules for GSS "
+					"(internal error %d) - are modules missing?", localRet);
+			ABORT_FINALIZE(localRet);
+		}
 	} else {
 		ABORT_FINALIZE(RS_RET_CONFLINE_UNPROCESSED);
 	}
 
-	/* ok, if we reach this point, we have something for us */
-	if((iRet = createInstance(&pData)) != RS_RET_OK)
-		goto finalize_it;
-
 	/* we are now after the protocol indicator. Now check if we should
 	 * use compression. We begin to use a new option format for this:
 	 * @(option,option)host:port
@@ -509,6 +911,9 @@ CODE_STD_STRING_REQUESTparseSelectorAct(1)
 	 * applies to TCP-based syslog only and is ignored when specified with UDP).
 	 * That is not yet implemented.
 	 * rgerhards, 2006-12-07
+	 * In order to support IPv6 addresses, we must introduce an extension to
+	 * the hostname. If it is in square brackets, whatever is in them is treated as
+	 * the hostname - without any exceptions ;) -- rgerhards, 2008-08-05
 	 */
 	if(*p == '(') {
 		/* at this position, it *must* be an option indicator */
@@ -516,7 +921,7 @@ CODE_STD_STRING_REQUESTparseSelectorAct(1)
 			++p; /* eat '(' or ',' (depending on when called) */
 			/* check options */
 			if(*p == 'z') { /* compression */
-#					ifdef USE_NETZIP
+#				ifdef USE_NETZIP
 				++p; /* eat */
 				if(isdigit((int) *p)) {
 					int iLevel;
@@ -528,10 +933,10 @@ CODE_STD_STRING_REQUESTparseSelectorAct(1)
 						 "forwardig action - NOT turning on compression.",
 						 *p);
 				}
-#					else
+#				else
 				errmsg.LogError(0, NO_ERRCODE, "Compression requested, but rsyslogd is not compiled "
 					 "with compression support - request ignored.");
-#					endif /* #ifdef USE_NETZIP */
+#				endif /* #ifdef USE_NETZIP */
 			} else if(*p == 'o') { /* octet-couting based TCP framing? */
 				++p; /* eat */
 				/* no further options settable */
@@ -553,14 +958,26 @@ CODE_STD_STRING_REQUESTparseSelectorAct(1)
 			/* we probably have end of string - leave it for the rest
 			 * of the code to handle it (but warn the user)
 			 */
-			errmsg.LogError(0, NO_ERRCODE, "Option block not terminated in gssapi forward action.");
+			errmsg.LogError(0, NO_ERRCODE, "Option block not terminated in forwarding action.");
 	}
+
 	/* extract the host first (we do a trick - we replace the ';' or ':' with a '\0')
 	 * now skip to port and then template name. rgerhards 2005-07-06
 	 */
-	for(q = p ; *p && *p != ';' && *p != ':' && *p != '#' ; ++p)
-		/* JUST SKIP */;
+	if(*p == '[') { /* everything is hostname upto ']' */
+		++p; /* skip '[' */
+		for(q = p ; *p && *p != ']' ; ++p)
+			/* JUST SKIP */;
+		if(*p == ']') {
+			*p = '\0'; /* trick to obtain hostname (later)! */
+			++p; /* eat it */
+		}
+	} else { /* traditional view of hostname */
+		for(q = p ; *p && *p != ';' && *p != ':' && *p != '#' ; ++p)
+			/* JUST SKIP */;
+	}
 
+	pData->tcp_framing = tcp_framing;
 	pData->port = NULL;
 	if(*p == ':') { /* process port */
 		uchar * tmp;
@@ -573,92 +990,108 @@ CODE_STD_STRING_REQUESTparseSelectorAct(1)
 		if(pData->port == NULL) {
 			errmsg.LogError(0, NO_ERRCODE, "Could not get memory to store syslog forwarding port, "
 				 "using default port, results may not be what you intend\n");
-			/* we leave f_forw.port set to NULL, this is then handled by
-			 * getFwdSyslogPt().
-			 */
+			/* we leave f_forw.port set to NULL, this is then handled below */
 		} else {
 			memcpy(pData->port, tmp, i);
 			*(pData->port + i) = '\0';
 		}
 	}
+	/* check if no port is set. If so, we use the IANA-assigned port of 514 */
+	if(pData->port == NULL) {
+		CHKmalloc(pData->port = strdup("514"));
+	}
 	
-		
 	/* now skip to template */
-	bErr = 0;
-	while(*p && *p != ';') {
-		if(*p && *p != ';' && !isspace((int) *p)) {
-			if(bErr == 0) { /* only 1 error msg! */
-				bErr = 1;
-				errno = 0;
-				errmsg.LogError(0, NO_ERRCODE, "invalid selector line (port), probably not doing "
-					 "what was intended");
-			}
-		}
-		++p;
-	}
+	while(*p && *p != ';'  && *p != '#' && !isspace((int) *p))
+		++p; /*JUST SKIP*/
 
-	/* TODO: make this if go away! */
 	if(*p == ';' || *p == '#' || isspace(*p)) {
 		uchar cTmp = *p;
 		*p = '\0'; /* trick to obtain hostname (later)! */
-		CHKmalloc(pData->f_hname = strdup((char*) q));
+		CHKmalloc(pData->target = strdup((char*) q));
 		*p = cTmp;
 	} else {
-		CHKmalloc(pData->f_hname = strdup((char*) q));
+		CHKmalloc(pData->target = strdup((char*) q));
 	}
 
+	/* copy over config data as needed */
+
 	/* process template */
-	CHKiRet(cflineParseTemplateName(&p, *ppOMSR, 0, OMSR_NO_RQD_TPL_OPTS,
-			(cs.pszTplName == NULL) ? (uchar*)"RSYSLOG_TraditionalForwardFormat" : cs.pszTplName));
-
-	/* first set the pData->eDestState */
-	memset(&hints, 0, sizeof(hints));
-	/* port must be numeric, because config file syntax requests this */
-	hints.ai_flags = AI_NUMERICSERV;
-	hints.ai_family = glbl.GetDefPFFamily();
-	hints.ai_socktype = SOCK_STREAM;
-	if( (error = getaddrinfo(pData->f_hname, getFwdSyslogPt(pData), &hints, &res)) != 0) {
-		pData->eDestState = eDestFORW_UNKN;
-	} else {
-		pData->eDestState = eDestFORW;
-		pData->f_addr = res;
+	CHKiRet(cflineParseTemplateName(&p, *ppOMSR, 0, OMSR_NO_RQD_TPL_OPTS, getDfltTpl()));
+
+	pData->bResendLastOnRecon = cs.bResendLastOnRecon;
+	pData->iStrmDrvrMode = cs.iStrmDrvrMode;
+	if(cs.pszStrmDrvr != NULL)
+		CHKmalloc(pData->pszStrmDrvr = (uchar*)strdup((char*)cs.pszStrmDrvr));
+	if(cs.pszStrmDrvrAuthMode != NULL)
+		CHKmalloc(pData->pszStrmDrvrAuthMode =
+			     (uchar*)strdup((char*)cs.pszStrmDrvrAuthMode));
+	if(cs.pPermPeers != NULL) {
+		pData->pPermPeers = cs.pPermPeers;
+		cs.pPermPeers = NULL;
 	}
 
-	/* now create our tcpclt */
-	CHKiRet(tcpclt.Construct(&pData->pTCPClt));
-	/* and set callbacks */
-	CHKiRet(tcpclt.SetSendInit(pData->pTCPClt, TCPSendGSSInit));
-	CHKiRet(tcpclt.SetSendFrame(pData->pTCPClt, TCPSendGSSSend));
-	CHKiRet(tcpclt.SetSendPrepRetry(pData->pTCPClt, TCPSendGSSPrepRetry));
-	CHKiRet(tcpclt.SetFraming(pData->pTCPClt, tcp_framing));
-
-	/* TODO: do we need to call freeInstance if we failed - this is a general question for
-	 * all output modules. I'll address it lates as the interface evolves. rgerhards, 2007-07-25
-	 */
+	CHKiRet(initTCP(pData));
 CODE_STD_FINALIZERparseSelectorAct
 ENDparseSelectorAct
 
 
+/* a common function to free our configuration variables - used both on exit
+ * and on $ResetConfig processing. -- rgerhards, 2008-05-16
+ */
+static void
+freeConfigVars(void)
+{
+	free(cs.pszStrmDrvr);
+	cs.pszStrmDrvr = NULL;
+	free(cs.pszStrmDrvrAuthMode);
+	cs.pszStrmDrvrAuthMode = NULL;
+	free(cs.pPermPeers);
+	cs.pPermPeers = NULL; /* TODO: fix in older builds! */
+        free(cs.gss_base_service_name);
+	cs.gss_base_service_name = NULL;
+}
+
+
 BEGINmodExit
 CODESTARTmodExit
-	objRelease(glbl, CORE_COMPONENT);
+	/* release what we no longer need */
 	objRelease(errmsg, CORE_COMPONENT);
-	objRelease(gssutil, LM_GSSUTIL_FILENAME);
+	objRelease(glbl, CORE_COMPONENT);
+	objRelease(net, LM_NET_FILENAME);
+	objRelease(netstrm, LM_NETSTRMS_FILENAME);
+	objRelease(netstrms, LM_NETSTRMS_FILENAME);
+        objRelease(gssutil, LM_GSSUTIL_FILENAME);
 	objRelease(tcpclt, LM_TCPCLT_FILENAME);
-
-	if(cs.pszTplName != NULL) {
-		free(cs.pszTplName);
-		cs.pszTplName = NULL;
-	}
+	freeConfigVars();
 ENDmodExit
 
 
 BEGINqueryEtryPt
 CODESTARTqueryEtryPt
 CODEqueryEtryPt_STD_OMOD_QUERIES
+CODEqueryEtryPt_STD_CONF2_QUERIES
+CODEqueryEtryPt_STD_CONF2_setModCnf_QUERIES
+CODEqueryEtryPt_STD_CONF2_OMOD_QUERIES
+CODEqueryEtryPt_TXIF_OMOD_QUERIES /* we support the transactional interface! */
 ENDqueryEtryPt
 
 
+/* Reset config variables for this module to default values.
+ * rgerhards, 2008-03-28
+ */
+static rsRetVal resetConfigVariables(uchar __attribute__((unused)) *pp, void __attribute__((unused)) *pVal)
+{
+	freeConfigVars();
+
+	/* we now must reset all non-string values */
+	cs.iStrmDrvrMode = 0;
+	cs.bResendLastOnRecon = 0;
+        cs.gss_mode = GSSMODE_ENC;
+        
+	return RS_RET_OK;
+}
+
 /* set a new GSSMODE based on config directive */
 static rsRetVal setGSSMode(void __attribute__((unused)) *pVal, uchar *mode)
 {
@@ -679,33 +1112,32 @@ static rsRetVal setGSSMode(void __attribute__((unused)) *pVal, uchar *mode)
 	RETiRet;
 }
 
-
-static rsRetVal resetConfigVariables(uchar __attribute__((unused)) *pp, void __attribute__((unused)) *pVal)
-{
-	cs.gss_mode = GSSMODE_ENC;
-	free(cs.gss_base_service_name);
-	cs.gss_base_service_name = NULL;
-	free(cs.pszTplName);
-	cs.pszTplName = NULL;
-	return RS_RET_OK;
-}
-
-
 BEGINmodInit()
 CODESTARTmodInit
+INITLegCnfVars
 	*ipIFVersProvided = CURR_MOD_IF_VERSION; /* we only support the current interface specification */
 CODEmodInit_QueryRegCFSLineHdlr
-	CHKiRet(objUse(errmsg, CORE_COMPONENT));
 	CHKiRet(objUse(glbl, CORE_COMPONENT));
-	CHKiRet(objUse(gssutil, LM_GSSUTIL_FILENAME));
+	CHKiRet(objUse(errmsg, CORE_COMPONENT));
+	CHKiRet(objUse(net,LM_NET_FILENAME));
+	CHKiRet(objUse(netstrms, LM_NETSTRMS_FILENAME));
+	CHKiRet(objUse(netstrm, LM_NETSTRMS_FILENAME));
+        CHKiRet(objUse(gssutil, LM_GSSUTIL_FILENAME));
 	CHKiRet(objUse(tcpclt, LM_TCPCLT_FILENAME));
 
-	CHKiRet(omsdRegCFSLineHdlr((uchar *)"gssforwardservicename", 0, eCmdHdlrGetWord, NULL, &cs.gss_base_service_name, STD_LOADABLE_MODULE_ID));
+	CHKiRet(omsdRegCFSLineHdlr((uchar *)"actiongssforwarddefaulttemplate", 0, eCmdHdlrGetWord, setLegacyDfltTpl, NULL, STD_LOADABLE_MODULE_ID));
+	CHKiRet(omsdRegCFSLineHdlr((uchar *)"actiongsssendstreamdriver", 0, eCmdHdlrGetWord, NULL, &cs.pszStrmDrvr, STD_LOADABLE_MODULE_ID));
+	CHKiRet(omsdRegCFSLineHdlr((uchar *)"actiongsssendstreamdrivermode", 0, eCmdHdlrInt, NULL, &cs.iStrmDrvrMode, STD_LOADABLE_MODULE_ID));
+	CHKiRet(omsdRegCFSLineHdlr((uchar *)"actiongsssendstreamdriverauthmode", 0, eCmdHdlrGetWord, NULL, &cs.pszStrmDrvrAuthMode, STD_LOADABLE_MODULE_ID));
+	CHKiRet(omsdRegCFSLineHdlr((uchar *)"actiongsssendstreamdriverpermittedpeer", 0, eCmdHdlrGetWord, setPermittedPeer, NULL, STD_LOADABLE_MODULE_ID));
+	CHKiRet(omsdRegCFSLineHdlr((uchar *)"actiongsssendresendlastmsgonreconnect", 0, eCmdHdlrBinary, NULL, &cs.bResendLastOnRecon, STD_LOADABLE_MODULE_ID));
+
+       	CHKiRet(omsdRegCFSLineHdlr((uchar *)"gssforwardservicename", 0, eCmdHdlrGetWord, NULL, &cs.gss_base_service_name, STD_LOADABLE_MODULE_ID));
 	CHKiRet(omsdRegCFSLineHdlr((uchar *)"gssmode", 0, eCmdHdlrGetWord, setGSSMode, &cs.gss_mode, STD_LOADABLE_MODULE_ID));
-	CHKiRet(omsdRegCFSLineHdlr((uchar *)"actiongssforwarddefaulttemplate", 0, eCmdHdlrGetWord, NULL, &cs.pszTplName, STD_LOADABLE_MODULE_ID));
+        
 	CHKiRet(omsdRegCFSLineHdlr((uchar *)"resetconfigvariables", 1, eCmdHdlrCustomHandler, resetConfigVariables, NULL, STD_LOADABLE_MODULE_ID));
 ENDmodInit
 
 #endif /* #ifdef USE_GSSAPI */
-/* vi:set ai:
+/* vim:set ai:
  */
